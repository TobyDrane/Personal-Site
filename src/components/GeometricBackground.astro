---
// Generative geometric background pattern
---

<canvas id="geometric-bg" class="fixed inset-0 w-full h-full -z-10 pointer-events-none"></canvas>

<script>
  const canvas = document.getElementById('geometric-bg') as HTMLCanvasElement;
  const ctx = canvas.getContext('2d')!;

  // Configuration
  const POINT_COUNT = 45;
  const CONNECTION_DISTANCE = 135;
  const DOT_RADIUS = 1.2;

  interface Point {
    x: number;
    y: number;
  }

  let points: Point[] = [];

  function isDarkMode(): boolean {
    return window.matchMedia('(prefers-color-scheme: dark)').matches;
  }

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    generatePoints();
    draw();
  }

  function generatePoints() {
    points = [];

    // Golden ratio angle for organic distribution
    const goldenAngle = Math.PI * (3 - Math.sqrt(5));

    for (let i = 0; i < POINT_COUNT; i++) {
      // Mix of golden ratio spiral and random placement
      const useSpiral = Math.random() > 0.4;

      if (useSpiral) {
        const radius = Math.sqrt(i / POINT_COUNT) * Math.min(canvas.width, canvas.height) * 0.45;
        const angle = i * goldenAngle;
        points.push({
          x: canvas.width / 2 + Math.cos(angle) * radius + (Math.random() - 0.5) * 100,
          y: canvas.height / 2 + Math.sin(angle) * radius + (Math.random() - 0.5) * 100
        });
      } else {
        points.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height
        });
      }
    }
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const dark = isDarkMode();
    const dotColor = dark ? 'rgba(115, 115, 115, 0.45)' : 'rgba(120, 120, 120, 0.6)';
    const lineColor = dark ? 'rgba(115, 115, 115, 0.12)' : 'rgba(120, 120, 120, 0.25)';

    // Draw connections using Delaunay-inspired nearest neighbor approach
    ctx.strokeStyle = lineColor;
    ctx.lineWidth = 1;

    for (let i = 0; i < points.length; i++) {
      const p1 = points[i];

      // Find and connect to nearby points
      for (let j = i + 1; j < points.length; j++) {
        const p2 = points[j];
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < CONNECTION_DISTANCE) {
          // Fade line opacity based on distance
          const opacity = 1 - (distance / CONNECTION_DISTANCE);
          ctx.strokeStyle = dark
            ? `rgba(115, 115, 115, ${0.12 * opacity})`
            : `rgba(120, 120, 120, ${0.25 * opacity})`;

          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.stroke();
        }
      }
    }

    // Draw dots
    ctx.fillStyle = dotColor;
    for (const point of points) {
      ctx.beginPath();
      ctx.arc(point.x, point.y, DOT_RADIUS, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Initialize
  resize();
  window.addEventListener('resize', resize);

  // Redraw on theme change
  window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', draw);
</script>
